/* eslint-disable */
/**
 * This file was automatically generated by cartesapp.template_generator.
 * DO NOT MODIFY IT BY HAND. Instead, run the generator,
 */
import Ajv, { ValidateFunction } from "ajv";
import addFormats from "ajv-formats";

import "viem/window";
import {
  createPublicClient,
  http,
  createWalletClient,
  custom,
  Chain,
  isHex,
  encodeAbiParameters,
  parseAbiParameters,
  bytesToString,
  Hex,
  toHex,
  WriteContractParameters,
  toBytes,
  decodeAbiParameters,
  hexToString,
  ByteArray,
  hexToBigInt,
  isBytes,
  bytesToBigInt,
} from "viem";

import {
  publicActionsL1,
  walletActionsL1,
  createCartesiPublicClient,
  Report as CartesiReport,
  Output as CartesiOutput,
  Input as CartesiInput,
  CartesiPublicClient,
  estimateAddInputGas,
  EstimateAddInputGasParameters,
  getInputsAdded,
  InputAdded,
} from "@cartesi/viem";

// import {
//     advanceInput, inspect,
//     AdvanceOutput, InspectOptions, AdvanceInputOptions,
//     Report as CartesiReport, Notice as CartesiNotice, Voucher as CartesiVoucher, Input as CartesiInput,
//     Maybe, Proof, validateNoticeFromParams, wasVoucherExecutedFromParams, executeVoucherFromParams,
//     queryNotice, queryReport, queryVoucher, queryInput, GraphqlOptions
// } from "cartesi-client";

import { inspect, InspectOptions, InspectReport } from "./inspect";
import { inputBoxAbi } from "@cartesi/viem/abi";
import { writeContract } from "viem/actions";

/**
 * Configs
 */

const ajv = new Ajv();
addFormats(ajv);
ajv.addFormat("biginteger", (data) => {
  const dataTovalidate = data.startsWith("-") ? data.substring(1) : data;
  return isHex(dataTovalidate) && dataTovalidate.length % 2 == 0;
});
// const abiCoder = new ethers.utils.AbiCoder();
export const CONVENTIONAL_TYPES: Array<string> = [
  "bytes",
  "hex",
  "str",
  "int",
  "dict",
  "list",
  "tuple",
  "json",
];

/**
 * Chains
 */

export async function getClient(chain: Chain) {
  if (!chain) return null;
  return createPublicClient({
    chain: chain,
    transport: http(),
  }).extend(publicActionsL1());
}

export async function getWalletClient(chain: Chain) {
  if (!window.ethereum) return null;
  if (!chain) return null;

  const accounts = await window.ethereum.request({
    method: "eth_requestAccounts",
  });
  return createWalletClient({
    account: accounts[0],
    chain: chain,
    transport: custom(window.ethereum),
  }).extend(walletActionsL1());
}

export async function getL2Client(nodeAddress: string) {
  if (!nodeAddress) return null;
  return createCartesiPublicClient({
    transport: http(nodeAddress),
  });
}

export type AsyncReturnType<T extends (..._args: any) => Promise<any>> =
  Awaited<ReturnType<T>>;
export type BaseLayerPublicClient = AsyncReturnType<typeof getClient>;
export type BaseLayerWalletClient = AsyncReturnType<typeof getWalletClient>;

export interface CartesiRpcParams {
  applicationAddress?: Hex;
  cartesiNodeUrl?: string;
  client?: CartesiPublicClient;
}

export interface CartesiRpcOptions {
  applicationAddress: Hex;
  client: CartesiPublicClient;
}

export async function ensureCartesiPublicClient(
  params: CartesiRpcParams,
): Promise<CartesiRpcOptions> {
  if (!params.applicationAddress)
    throw new Error("No application address defined.");
  let client: CartesiPublicClient | null;
  if (params.client) {
    client = params.client;
  } else {
    if (!params.cartesiNodeUrl)
      throw new Error(
        "Couldn't get Cartesi Public Client: No node url defined.",
      );
    client = await getL2Client(params.cartesiNodeUrl);
    if (!client)
      throw new Error(
        "Couldn't get Cartesi Public Client: No node url defined.",
      );
  }
  return {
    applicationAddress: params.applicationAddress,
    client: client,
  };
}

export interface BaseLayerPublicOptions {
  applicationAddress: Hex;
  client: BaseLayerPublicClient;
}

export interface BaseLayerWalletOptions {
  applicationAddress: Hex;
  client: BaseLayerWalletClient;
  gas?: bigint | null | undefined;
  inputBoxAddress?: Hex;
}

/**
 * Models
 */

export enum IOType {
  report,
  notice,
  noticeHeader,
  voucher,
  mutationPayload,
  queryPayload,
  queryUrlPayload,
  queryJsonPayload,
  queryJsonrpcPayload,
}

interface ModelInterface<T> {
  ioType: IOType;
  abiTypes: string[];
  params: string[];
  decoder?(
    data: CartesiInput | CartesiOutput | CartesiReport | InspectReport,
  ): T;
  exporter?(data: T): string;
  validator: ValidateFunction<T>;
}

export interface Models {
  [key: string]: ModelInterface<any>;
}

export interface OutputGetters {
  [key: string]: (
    p: CartesiRpcParams,
    i: bigint,
  ) => Promise<CartesiInput | CartesiOutput | CartesiReport | InspectReport>;
}

export const outputGetters: OutputGetters = {
  report: queryReport,
  notice: queryOutput,
  voucher: queryOutput,
  delegatedcallvoucher: queryOutput,
  input: queryInput,
};

export interface MutationOptions {
  decode?: boolean;
  sync?: boolean;
  cartesiNodeUrl?: string;
  initialDelay?: number;
  delayInterval?: number;
}

export interface QueryOptions extends InspectOptions {
  decode?: boolean;
  decodeModel?: string;
}

export class IOData<T extends object> {
  [key: string]: any;
  _model: ModelInterface<T>;

  constructor(model: ModelInterface<T>, data: T, validate: boolean = true) {
    this._model = model;
    for (const key of this._model.params) {
      this[key] = (data as any)[key];
    }
    if (validate) this.validate();
  }

  get = (): T => {
    const data: Record<string, unknown> = {};
    for (const key of this._model.params) {
      data[key] = this[key];
    }
    return data as T;
  };

  validate = (): boolean => {
    const dataToValidate: any = { ...this.get() };
    // for (const k of Object.keys(dataToValidate)) {
    //   if (
    //     dataToValidate[k] === parseInt(dataToValidate[k], 10) &&
    //     this._model.ioType == IOType.mutationPayload
    //   )
    //     // is int
    //     dataToValidate[k] = ethers.BigNumber.from(dataToValidate[k]);
    //   if (ethers.BigNumber.isBigNumber(dataToValidate[k]))
    //     dataToValidate[k] = dataToValidate[k].toHexString();
    // }
    if (!this._model.validator(dataToValidate))
      throw new Error(
        `Data does not implement interface: ${ajv.errorsText(this._model.validator.errors)}`,
      );
    return true;
  };

  export(selectorInfo?: string): string {
    let payload: string;
    switch (this._model.ioType) {
      case IOType.mutationPayload: {
        // parametrize input to url
        const inputData: any = this.get();
        const paramList = Array<any>();
        for (const key of this._model.params) {
          paramList.push(inputData[key]);
        }
        payload = encodeAbiParameters(
          parseAbiParameters(this._model.abiTypes.join(",")),
          paramList,
        );
        if (selectorInfo) {
          payload = selectorInfo + payload.replace("0x", "");
        }
        break;
      }
      case IOType.queryUrlPayload: {
        // parametrize input to url
        if (!selectorInfo) throw new Error(`Selector info not defined`);
        const inputData: any = this.get();
        const excludeParams: string[] = [];
        const matchRoute = selectorInfo.matchAll(/\{(\w+)\}/g);
        for (const m of matchRoute) {
          selectorInfo = selectorInfo.replace(m[0], inputData[m[1]]);
          excludeParams.push(m[1]);
        }
        const paramList = Array<string>();
        for (const key in inputData) {
          if (inputData[key] == undefined) continue;
          if (excludeParams.indexOf(key) > -1) continue;
          if (Array.isArray(inputData[key])) {
            for (const element in inputData[key]) {
              paramList.push(`${key}=${inputData[key][element]}`);
            }
          } else {
            paramList.push(`${key}=${inputData[key]}`);
          }
        }
        payload = `${selectorInfo}${paramList.length > 0 ? `?${paramList.join("&")}` : ""}`;
        break;
      }
      case (IOType.queryPayload,
      IOType.queryJsonPayload,
      IOType.queryJsonrpcPayload): {
        // parametrize input to url
        const inputData: T = this.get();
        const paramList = Array<unknown>();
        for (const key in inputData) {
          paramList.push(inputData[key]);
        }
        const jsonObj: Record<string, unknown> = {
          method: selectorInfo,
          params: paramList,
        };
        if (this._model.ioType == IOType.queryJsonrpcPayload) {
          jsonObj["jsonrpc"] = "2.0";
          jsonObj["id"] = Math.floor(Math.random() * 1000 + 1);
        }
        payload = JSON.stringify(jsonObj);
        break;
      }
      default: {
        throw new Error(`Invalid payload type ${this._model.ioType}`);
        // break;
      }
    }
    return payload;
  }
}

export class BasicIO<T extends object> extends IOData<T> {
  _payload: Hex | Uint8Array;
  _inputIndex?: bigint;
  _blockTimestamp?: bigint;
  _blockNumber?: bigint;
  _msgSender?: string;

  constructor(
    model: ModelInterface<T>,
    payload: Hex | Uint8Array,
    blockTimestamp?: bigint,
    blockNumber?: bigint,
    msgSender?: string,
    inputIndex?: bigint,
    proxyMsgSender: boolean = false,
  ) {
    if (proxyMsgSender) {
      msgSender = `0x${payload.slice(10, 50)}`;
      payload = `0x${payload.slice(2, 10)}${payload.slice(50)}`;
    }
    super(model, genericDecodeTo<T>(payload, model), false);
    this._blockTimestamp = blockTimestamp;
    this._blockNumber = blockNumber;
    this._msgSender = msgSender;
    this._inputIndex = inputIndex;
    this._payload = payload;
  }
  getInput = async (params: CartesiRpcParams) => {
    const options = await ensureCartesiPublicClient(params);
    if (!this._inputIndex) throw new Error(`No input index`);
    const input = await options.client.getInput({
      application: options.applicationAddress,
      inputIndex: this._inputIndex,
    });
    this.setInput(input);
  };
  setInput = (input: CartesiInput) => {
    this._blockTimestamp = input.decodedData.blockTimestamp;
    this._blockNumber = input.decodedData.blockNumber;
    this._msgSender = input.decodedData.sender;
  };
}

export class Input<T extends object> extends BasicIO<T> {
  constructor(
    model: ModelInterface<T>,
    input: CartesiInput,
    proxyMsgSender: boolean = false,
  ) {
    super(
      model,
      input.decodedData.payload,
      input.decodedData.blockTimestamp,
      input.decodedData.blockNumber,
      input.decodedData.sender,
      input.index,
      proxyMsgSender,
    );
  }
}

export class Output<T extends object> extends BasicIO<T> {
  _output: CartesiReport | InspectReport;
  _outputIndex?: bigint;
  constructor(model: ModelInterface<T>, report: CartesiReport | InspectReport) {
    super(model, report.rawData, report.inputIndex);
    this._output = report;
    this._outputIndex = report.index;
  }
}

export class OutputWithProof<T extends object> extends BasicIO<T> {
  _output: CartesiOutput;
  _outputIndex: bigint;

  constructor(model: ModelInterface<T>, output: CartesiOutput) {
    super(model, output.decodedData.payload, output.inputIndex);
    this._output = output;
    this._outputIndex = output.index;
  }
  validateOnchain = async (options: BaseLayerPublicOptions) => {
    return await options.client?.validateOutput({
      application: options.applicationAddress,
      output: this._output,
    });
  };
  wasExecuted = async () => {
    return this._output.executionTransactionHash != null;
  };
  execute = async (options: BaseLayerWalletOptions) => {
    // hash: Hash;
    // outputHashesSiblings: Hash[];
    if (
      !this._output.hash ||
      !this._output.outputHashesSiblings ||
      !this._output.outputHashesSiblings.length
    )
      throw new Error("Output has no proof");
    if (!options.client) return;
    const [address] = await options.client.requestAddresses();
    if (!address) return;
    return await options.client?.executeOutput({
      application: options.applicationAddress,
      output: this._output,
      account: address,
      chain: options.client.chain,
      gas: options.gas,
    });
  };
}

/*
 * Helpers
 */

// Advance
export async function genericAdvanceInput<T extends object>(
  options: BaseLayerWalletOptions,
  selector: string,
  inputData: IOData<T>,
) {
  if (!options.client) return [];
  const [address] = await options.client.requestAddresses();
  if (!address) return [];

  const publicClient = await getClient(options.client.chain);
  if (!publicClient) return [];

  const payloadHex = inputData.export(selector) as Hex;
  let hash: Hex;

  if (!options.inputBoxAddress) {
    hash = await options.client.addInput({
      application: options.applicationAddress,
      payload: payloadHex,
      account: address,
      chain: options.client.chain,
      gas: options.gas,
    });
  } else {
    const gas_ =
      typeof options.gas !== "number" && options.gas !== null
        ? await estimateAddInputGas(options.client, {
            application: options.applicationAddress,
            payload: payloadHex,
            account: address,
            chain: options.client.chain,
            gas: options.gas,
          } as EstimateAddInputGasParameters)
        : undefined;

    hash = await writeContract(options.client, {
      account: address!,
      abi: inputBoxAbi,
      address: options.inputBoxAddress,
      chain: options.client.chain,
      functionName: "addInput",
      args: [options.applicationAddress, payloadHex],
      gas: gas_,
    } satisfies WriteContractParameters as any);
  }
  const receipt = await publicClient.waitForTransactionReceipt({
    hash,
    timeout: 6000,
  });
  return getInputsAdded(receipt);
}

export type AdvanceResult = CartesiOutput | CartesiReport;

export async function listAdvanceResults(
  params: CartesiRpcParams,
  inputsAdded: InputAdded[],
): Promise<Array<AdvanceResult>> {
  const options = await ensureCartesiPublicClient(params);
  const results: Array<AdvanceResult> = [];
  for (const inputAdded of inputsAdded) {
    results.concat(
      (
        await options.client.listOutputs({
          application: inputAdded.appContract,
          inputIndex: inputAdded.index,
        })
      ).data,
    );
    results.concat(
      (
        await options.client.listReports({
          application: inputAdded.appContract,
          inputIndex: inputAdded.index,
        })
      ).data,
    );
  }
  return results;
}

export async function queryInput(
  params: CartesiRpcParams,
  index: bigint,
): Promise<CartesiInput> {
  const options = await ensureCartesiPublicClient(params);
  const out = await options.client.getInput({
    application: options.applicationAddress,
    inputIndex: index,
  });
  return out;
}

export async function queryReport(
  params: CartesiRpcParams,
  index: bigint,
): Promise<CartesiReport> {
  const options = await ensureCartesiPublicClient(params);
  const out = await options.client.getReport({
    application: options.applicationAddress,
    reportIndex: index,
  });
  return out;
}

export async function queryOutput(
  params: CartesiRpcParams,
  index: bigint,
): Promise<CartesiOutput> {
  const options = await ensureCartesiPublicClient(params);
  const out = await options.client.getOutput({
    application: options.applicationAddress,
    outputIndex: index,
  });
  return out;
}

// Inspect
export async function inspectCall(
  payload: string,
  options: InspectOptions,
): Promise<InspectReport> {
  options.decodeTo = "no-decode";
  const payloadHex = toHex(payload);
  const inspectResult = await inspect(payloadHex, options).catch((e) => {
    if (String(e.message).startsWith("0x"))
      throw new Error(bytesToString(e.message));
    throw new Error(e.message);
  }); // hex string
  return { rawData: inspectResult };
}

export async function genericInspect<T extends object>(
  inputData: IOData<T>,
  selectorInfo: string,
  options?: InspectOptions,
): Promise<InspectReport> {
  if (options == undefined) options = {};
  options.aggregate = true;
  // const excludeParams: string[] = [];
  // const matchRoute = route.matchAll(/\{(\w+)\}/g);
  // for (const m of matchRoute) {
  //   route = route.replace(m[0], inputData[m[1]]);
  //   excludeParams.push(m[1]);
  // }
  // const payload = `${route}${inputData.export(excludeParams)}`;
  const payload = inputData.export(selectorInfo);
  return await inspectCall(payload, options);
}

// Decode
export function genericDecodeTo<T extends object>(
  data: Hex | Uint8Array,
  model: ModelInterface<T>,
): T {
  let dataObj: any;
  switch (model.ioType) {
    case (IOType.queryPayload, IOType.report, IOType.queryJsonPayload): {
      let dataStr: string;
      if (typeof data == "string") {
        dataStr = bytesToString(toBytes(data));
      } else {
        dataStr = bytesToString(data);
      }
      try {
        dataObj = JSON.parse(dataStr);
      } catch (e) {
        throw new Error(dataStr);
      }
      dataObj = JSON.parse(dataStr);
      if (!model.validator(dataObj))
        throw new Error(
          `Data does not implement interface: ${ajv.errorsText(model.validator.errors)}`,
        );
      break;
    }
    case IOType.queryJsonPayload: {
      let dataStr: string;
      if (typeof data == "string") {
        dataStr = hexToString(data);
      } else {
        dataStr = bytesToString(data);
      }
      try {
        dataObj = JSON.parse(dataStr);
      } catch (e) {
        throw new Error(dataStr);
      }
      dataObj = JSON.parse(dataStr)?.result;
      if (!model.validator(dataObj))
        throw new Error(
          `Data does not implement interface: ${ajv.errorsText(model.validator.errors)}`,
        );
      break;
    }
    case IOType.notice: {
      const dataValues = decodeAbiParameters(
        parseAbiParameters(model.abiTypes.join(",")),
        data,
      );
      dataObj = {};
      let ind = 0;
      for (const key of model.params) {
        dataObj[key] = dataValues[ind];
        ind++;
      }
      const dataToValidate = { ...dataObj };
      // for (const k of Object.keys(dataToValidate)) {
      //   if (ethers.BigNumber.isBigNumber(dataToValidate[k]))
      //     dataToValidate[k] = dataToValidate[k].toHexString();
      // }
      if (!model.validator(dataToValidate))
        throw new Error(
          `Data does not implement interface: ${ajv.errorsText(model.validator.errors)}`,
        );

      break;
    }
    case (IOType.voucher, IOType.mutationPayload, IOType.noticeHeader): {
      const dataValues = decodeAbiParameters(
        parseAbiParameters(`bytes4,${model.abiTypes.join(",")}`),
        data,
      );
      dataObj = {};
      let ind = 0;
      for (const key of model.params) {
        if (ind == 0) continue; // skip selector
        dataObj[key] = dataValues[ind - 1];
        ind++;
      }
      const dataToValidate = { ...dataObj };
      // for (const k of Object.keys(dataToValidate)) {
      //   if (ethers.BigNumber.isBigNumber(dataToValidate[k]))
      //     dataToValidate[k] = dataToValidate[k].toHexString();
      // }
      if (!model.validator(dataToValidate))
        throw new Error(
          `Data does not implement interface: ${ajv.errorsText(model.validator.errors)}`,
        );
      break;
    }
    default: {
      throw new Error(`Cannot convert ${model.ioType}`);
      // break;
    }
  }
  return dataObj;
}

export function decodeToConventionalTypes(
  data: Hex | ByteArray,
  modelName: string,
): any {
  if (!CONVENTIONAL_TYPES.includes(modelName))
    throw new Error(`Cannot decode to ${modelName}`);
  switch (modelName) {
    case "bytes": {
      if (typeof data == "string") {
        if (isHex(data)) return toBytes(data);
        else throw new Error(`Cannot decode to bytes`);
      }
      return data;
    }
    case "hex": {
      return data;
    }
    case "str": {
      return isHex(data) ? hexToString(data) : bytesToString(data);
    }
    case "int": {
      if (typeof data == "string") {
        if (isHex(data)) return hexToBigInt(data);
        else throw new Error(`Cannot decode to int`);
      }
      if (isBytes(data)) return bytesToBigInt(data);
      else throw new Error(`Cannot decode to int`);
    }
    case "dict":
    case "list":
    case "tuple":
    case "json": {
      return JSON.parse(isHex(data) ? hexToString(data) : bytesToString(data));
    }
  }
}
