/* eslint-disable */
/**
 * This file was automatically generated by cartesapp.template_generator.
 * DO NOT MODIFY IT BY HAND. Instead, run the generator,
 */

import {
  Report as CartesiReport,
  Output as CartesiOutput,
  Input as CartesiInput,
} from "@cartesi/viem";
import { InspectOptions, InspectReport } from "./inspect";


import {
  AdvanceResult,
  ensureCartesiPublicClient,
  outputGetters,
} from "./utils";

{% if add_indexer_query -%}
import * as indexerIfaces from "../indexer/ifaces";
import * as indexerLib from "../indexer/lib";

interface OutMap {
  [key: string]: AdvanceResult;
}
type outType = "report" | "output";
type AdvanceOutputMap = Record<outType, OutMap>;

export interface DecodedIndexerOutput {
  data: any[];
  page: number;
  total: number;
}

export async function decodeAdvance(
  advanceResults: AdvanceResult[],
  decoder: (
    data: CartesiInput | CartesiOutput | CartesiReport | InspectReport,
    modelName: string,
  ) => any,
  options?: InspectOptions,
): Promise<any[]> {
  let inputIndex: number;

  if (advanceResults.length > 0) {
    const result = advanceResults[0];
    inputIndex = Number(result.inputIndex);
  } else {
    // Can't decode outputs (no outputs)
    return [];
  }
  const outMap: AdvanceOutputMap = {
    report: {},
    output: {},
  };

  for (const result of advanceResults) {
    outMap.report[result.index.toString()] = result;
  }
  const indexerOutput: indexerLib.{{ indexer_output_info['model'].__name__ }} =
    (await indexerLib.{{ convert_camel_case(indexer_query_info['method']) }}(
      {input_index:inputIndex},
      {...options, decode:true, decodeModel:"{{ indexer_output_info['model'].__name__ }}"},
    )) as indexerLib.{{ indexer_output_info['model'].__name__ }};

  const outList: any[] = [];
  for (const indOut of indexerOutput.data) {
    const outType = indOut.type == "report" ? indOut.type : "output";
    let out: CartesiInput | CartesiOutput | CartesiReport | InspectReport;
    if (outType == "output") {
      out = (
        outMap[outType as outType][`${indOut.output_index}`] as CartesiOutput
      );
    } else {
      out = outMap[outType as outType][`${indOut.output_index}`];
    }
    outList.push(decoder(out, indOut.class_name));
  }
  return outList;
}

// indexer
export async function genericGetOutputs(
  inputData: indexerIfaces.{{ indexer_query_info['model'].__name__ }},
  decoder: (
    data: CartesiInput | CartesiOutput | CartesiReport | InspectReport,
    modelName: string
  ) => any,
  options?: InspectOptions,
): Promise<DecodedIndexerOutput> {
  if (options == undefined) options = {};
  const indexerOutput: indexerLib.{{ indexer_output_info['model'].__name__ }} =
    (await indexerLib.{{ convert_camel_case(indexer_query_info['method']) }}(inputData,{
      ...options,
      decode:true,
      decodeModel:"{{ indexer_output_info['model'].__name__ }}"}
    )) as indexerLib.{{ indexer_output_info['model'].__name__ }};
  const dataQueries: Promise<any>[] = [];
  const rpcOptions = await ensureCartesiPublicClient({
    applicationAddress: options.applicationAddress,
    cartesiNodeUrl: options.cartesiNodeUrl,
  });
  for (const outInd of indexerOutput.data) {
    dataQueries.push(
      outputGetters[outInd.type](rpcOptions, outInd.input_index).then(
        (
          output: CartesiInput | CartesiOutput | CartesiReport | InspectReport
        ) => {
          return decoder(output, outInd.class_name);
        },
      ),
    );
  }
  return Promise.all(dataQueries).then((data: any[]) => {
    return { page: indexerOutput.page, total: indexerOutput.total, data: data };
  });
}

{% endif %}
