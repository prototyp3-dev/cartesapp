/**
 * This file was automatically generated by cartesapp.template_generator.
 * DO NOT MODIFY IT BY HAND. Instead, run the generator,
 */
import React, { useState, useEffect } from "react";
import { type Hex } from "viem";
import Form from "@rjsf/core";
import validator from "@rjsf/validator-ajv8";

import {
  getChain,
  type INodeComponentProps,
  type ListFunctionInfo,
} from "./utils";

import {
  type BaseLayerWalletClient,
  getWalletClient,
  type MutationOptions,
} from "./{{base_dir}}/cartesapp/utils";

{% for mod in all_modules.keys() -%}
import {
  {% for info in all_modules[mod]['mutations_info'] -%}
  {{convert_camel_case(info['method'])}} as {{mod}}{{convert_camel_case(info['method'],True)}},
  {% endfor -%}
} from "./{{base_dir}}/{{mod}}/lib";
{% endfor %}

const funcInfos: ListFunctionInfo = {
  {% for mod in all_modules.keys() -%}
  {% for info in all_modules[mod]['mutations_info'] -%}
  "{{mod}}.{{convert_camel_case(info['method'])}}": {
    method: {{mod}}{{convert_camel_case(info['method'],True)}},
    schema: JSON.parse(
      '{{ info["model"].schema_json() }}'.replace(
        /integer/g,
        'string","format":"biginteger',
      ),
    ),
  },
  {% endfor -%}
  {% endfor -%}
};

async function mutation(
  data: unknown,
  selectedMethod: string,
  client?: BaseLayerWalletClient,
  applicationAddress?: Hex,
) {
  if (!funcInfos[selectedMethod] || !client || !applicationAddress) return;
  await funcInfos[selectedMethod].method(data, {
    applicationAddress,
    client,
  } as MutationOptions);
}
export const Input: React.FC<INodeComponentProps> = (
  props: INodeComponentProps,
) => {
  const [client, setClient] = useState<BaseLayerWalletClient>();
  const [selectedMethod, setSelectedMethod] = useState<string>("");

  useEffect(() => {
    if (!props.chain) return;
    const chain = getChain(props.chain);
    if (!chain) return;
    getWalletClient(chain).then((newClient) => {
      if (!newClient) {
        setClient(undefined);
        return;
      }
      setClient(newClient);
    });
  }, [props.chain]);

  return (
    <div>
      <div>
        <select onChange={(e) => setSelectedMethod(e.target.value)}>
          <option value={""}>-</option>
          {Object.keys(funcInfos).map((func, index) => (
            <option key={index} value={func}>
              {func}
            </option>
          ))}
        </select>
        <Form
          schema={funcInfos[selectedMethod]?.schema || {}}
          validator={validator}
          // onChange={log('changed')}
          onSubmit={({ formData }) =>
            mutation(formData, selectedMethod, client, props.appAddress)
          }
          // onError={log("errors")}
        />
      </div>
    </div>
  );
};
