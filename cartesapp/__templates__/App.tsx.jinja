/**
 * This file was automatically generated by cartesapp.template_generator.
 * DO NOT MODIFY IT BY HAND. Instead, run the generator,
 */
import { type FC, useState } from "react";
import "viem/window";
import { type Hex, type Chain, hexToNumber, numberToHex } from "viem";

import { chains } from "./utils";

import { Inspect } from "./Inspect";
import { Input } from "./Input";
{% if add_wallet -%}import { Portals } from "./Portals";{% endif -%}
import { Reports } from "./Reports";
import { Outputs } from "./Outputs";

type NetworkProp = typeof Network extends FC<infer P> ? P : never;

const App: FC = () => {
  const [appAddress, setAppAddress] = useState<Hex | undefined>(
    "0x73C04b5b77A28A43c948B1aa34EcAF1fE3e7890f",
  );
  const [nodeAddress, setNodeAddress] = useState<string | undefined>(
    "http://localhost:8080",
  );

  const [chainId, setChainId] = useState<number>();

  const connect: NetworkProp["onChange"] = (chain) => {
    setChainId(chain);
  };

  const handleAddres = (value: string) => {
    setAppAddress(value as Hex);
  };

  return (
    <div>
      <Network onChange={connect} />
      {chainId ? (
        <>
          <br />
          <div>
            Dapp Address:{" "}
            <input
              type="text"
              value={appAddress}
              onChange={(e) => {
                handleAddres(e.target.value);
              }}
            />
          </div>
          <br />
          <div>
            Node Address:{" "}
            <input
              type="text"
              value={nodeAddress}
              onChange={(e) => {
                setNodeAddress(e.target.value);
              }}
            />
            <br />
          </div>
          {appAddress && nodeAddress ? (
            <>
              <h2>Inspect</h2>
              <Inspect
                chain={chainId}
                appAddress={appAddress}
                nodeAddress={nodeAddress}
              />
              <h2>Input</h2>
              <Input
                chain={chainId}
                appAddress={appAddress}
                nodeAddress={nodeAddress}
              />
              {% if add_wallet -%}
              <h2>Portals</h2>
              <Portals
                chain={chainId}
                appAddress={appAddress}
                nodeAddress={nodeAddress}
              />
              {% endif %}
              <h2>Reports</h2>
              <Reports
                chain={chainId}
                appAddress={appAddress}
                nodeAddress={nodeAddress}
              />
              <h2>Outputs</h2>
              <Outputs
                chain={chainId}
                appAddress={appAddress}
                nodeAddress={nodeAddress}
              />
            </>
          ) : (
            <></>
          )}
        </>
      ) : (
        <></>
      )}
    </div>
  );
};

export default App;

interface Propos {
  onChange(chain: number | undefined, address: `0x${string}` | undefined): void;
}

export const Network: FC<Propos> = ({ onChange }) => {
  const [chain, setChain] = useState<string | undefined>("0x7a69");
  const [connectedChain, setConnectedChain] = useState<string | undefined>();
  const [walletAddress, setWalletAddress] = useState<string>();

  const accountsChanged = (accounts: string[]) => {
    if (accounts.length === 0) {
      // MetaMask is locked or the user has not connected any accounts.
      setChain(undefined);
      setWalletAddress(undefined);
      setConnectedChain(undefined);
      onChange(undefined, undefined);
      return;
    } else if (accounts[0] !== walletAddress) {
      // Reload your interface with accounts[0].
      setWalletAddress(accounts[0]);
    }
  };

  const chainChanged = (chainId: string) => {
    window.ethereum
      ?.request({ method: "eth_requestAccounts" })
      .then((accounts) => {
        if (!accounts || accounts.length === 0) {
          setChain(undefined);
          setWalletAddress(undefined);
          setConnectedChain(undefined);
          onChange(undefined, undefined);
          return;
        }

        setChain(chainId);
        setConnectedChain(chainId);
        setWalletAddress(accounts[0]);
        onChange(hexToNumber(chainId as `0x${string}`), accounts[0]);
      });
  };

  window.ethereum?.removeListener("accountsChanged", accountsChanged);
  window.ethereum?.removeListener("chainChanged", chainChanged);
  window.ethereum?.on("accountsChanged", accountsChanged);
  window.ethereum?.on("chainChanged", chainChanged);

  async function connect() {
    if (!chain) return;
    try {
      if (!window.ethereum) {
        alert("no provider");
        return;
      }

      await window.ethereum?.request({
        method: "wallet_switchEthereumChain",
        params: [{ chainId: chain }],
      });

      const accounts = await window.ethereum?.request({
        method: "eth_requestAccounts",
      });

      if (!accounts || accounts.length === 0) {
        setChain(undefined);
        setWalletAddress(undefined);
        onChange(undefined, undefined);
        return;
      }

      setConnectedChain(chain);
      setWalletAddress(accounts[0]);

      onChange(parseInt(chain), accounts[0]);
    } catch (error) {
      console.log(error);
    }
  }

  return (
    <div>
      <div>
        <select
          onChange={(e) => {
            if (chains[parseInt(e.target.value)]) {
              setChain(e.target.value);
            } else {
              alert("No deploy on this chain");
            }
          }}
          value={chain}
        >
          {Object.entries(chains).map(([id, chain]: [string, Chain]) => {
            return (
              <option key={id} value={numberToHex(parseInt(id))}>
                {chain.name}
              </option>
            );
          })}
        </select>
        <button onClick={() => connect()}>connect</button>
      </div>
      {walletAddress ? (
        <div>
          Connected wallet: {walletAddress}
          <br />
        </div>
      ) : (
        <></>
      )}
      {connectedChain ? (
        <div>
          Connected chainId: {parseInt(connectedChain?.substring(2) ?? "0", 16)}
          <br />
        </div>
      ) : (
        <></>
      )}
    </div>
  );
};
