/**
 * This file was automatically generated by cartesapp.template_generator.
 * DO NOT MODIFY IT BY HAND. Instead, run the generator,
 */
import React, { type ChangeEvent, useEffect, useState } from "react";
import { fromHex, isHex } from "viem";
import { type Report } from "@cartesi/viem";
import { getL2Client } from "./{{base_dir}}/cartesapp/utils";
import { type DecoderMethods, type INodeComponentProps } from "./utils";

{% for mod in all_modules.keys() -%}
import {
  {% for info in all_modules[mod]['reports_info'] -%}
  decodeTo{{convert_camel_case(info['class'],True)}} as decodeTo{{mod.title()}}{{convert_camel_case(info['class'],True)}},
  {% endfor -%}
} from "./{{base_dir}}/{{mod}}/lib";
{% endfor %}

const decoders: DecoderMethods = {
  {% for mod in all_modules.keys() -%}
  {% for info in all_modules[mod]['reports_info'] -%}
  "{{mod}}.{{convert_camel_case(info['class'],True)}}": { method: decodeTo{{mod.title()}}{{convert_camel_case(info['class'],True)}} },
  {% endfor -%}
  {% endfor -%}
};

type RpcFilter = {
  limit?: number;
  offset?: number;
  epochIndex?: bigint;
  inputIndex?: bigint;
};

async function getReports(
  appAddress: string,
  nodeAddress: string,
  filter?: RpcFilter,
) {
  if (!nodeAddress) return [];
  const client = await getL2Client(nodeAddress + "/rpc");
  if (!client) return [];
  const reportResponse = await client.listReports({
    ...filter,
    application: appAddress,
  });
  return reportResponse.data;
}

export const Reports: React.FC<INodeComponentProps> = (
  props: INodeComponentProps,
) => {
  const [fetching, setFetching] = useState<boolean>(false);
  const [error, setError] = useState<string>();
  const [showFilter, setShowFilter] = useState<boolean>(false);
  const [reports, setReports] = useState<Report[]>([]);
  const [decodedMsg, setDecodedMsg] = useState<string>();
  const [lastCombo, setLastCombo] = useState<EventTarget & HTMLSelectElement>();
  const [limit, setLimit] = useState<number>();
  const [offset, setOffset] = useState<number>();
  const [epochIndex, setEpochIndex] = useState<number>();
  const [inputIndex, setInputIndex] = useState<number>();

  useEffect(() => {
    setFetching(true);
    setDecodedMsg(undefined);
    setLastCombo(undefined);
    getReports(props.appAddress, props.nodeAddress)
      .then((out) => setReports(out))
      .finally(() => setFetching(false));
  }, [props]);

  async function loadReports() {
    if (!props.chain) {
      setError("No connected chain");
      return;
    }
    setFetching(true);
    setDecodedMsg(undefined);
    setLastCombo(undefined);
    const out = await getReports(props.appAddress, props.nodeAddress, {
      limit,
      offset,
      epochIndex: epochIndex ? BigInt(epochIndex) : undefined,
      inputIndex: inputIndex ? BigInt(inputIndex) : undefined,
    });
    setReports(out);
    setFetching(false);
  }

  if (fetching) return <p>Loading...</p>;
  if (error) return <p>Oh no... {error}</p>;

  if (!reports) return <p>No reports</p>;

  const textdecoder = new TextDecoder("utf8", { fatal: true });

  async function selectDecoder(
    el: ChangeEvent<HTMLSelectElement>,
    output: Report,
  ) {
    if (lastCombo) {
      lastCombo.value = "";
    }
    setLastCombo(el.target);
    decodeOutput(el.target.value, output);
  }

  async function decodeOutput(className: string, output: Report) {
    setDecodedMsg(undefined);
    if (!decoders[className]) return;
    const ret = decoders[className].method(output);
    setDecodedMsg(
      JSON.stringify(
        ret,
        (_, value) =>
          typeof value === "bigint" ? value.toString() + "n" : value,
        2,
      ),
    );
  }
  return (
    <div>
      <button onClick={() => setShowFilter(!showFilter)}>Toggle Filter</button>
      <div hidden={!showFilter}>
        Limit:{" "}
        <input
          type="number"
          value={limit || ""}
          onChange={(e) => setLimit(parseInt(e.target.value))}
        />
        <br />
        Offset:{" "}
        <input
          type="number"
          value={offset || ""}
          onChange={(e) => setOffset(parseInt(e.target.value))}
        />
        <br />
        Epoch:{" "}
        <input
          type="number"
          value={epochIndex || ""}
          onChange={(e) => setEpochIndex(parseInt(e.target.value))}
        />
        <br />
        Input:{" "}
        <input
          type="text"
          value={inputIndex || ""}
          onChange={(e) => setInputIndex(parseInt(e.target.value))}
        />
      </div>
      <br />
      <button onClick={() => loadReports()}>Reload</button>
      <br />
      <br />
      <span className="text-bold">Decoded:</span>
      <p style={ { whiteSpace: "pre-wrap" } }>{decodedMsg}</p>
      <br />
      <br />
      <table>
        <thead>
          <tr>
            <th>Date</th>
            <th>Input Id</th>
            <th>Report Index</th>
            <th>Actions</th>
            <th>Payload</th>
          </tr>
        </thead>
        <tbody>
          {reports.length === 0 && (
            <tr>
              <td colSpan={4}>no reports</td>
            </tr>
          )}
          {reports.map((n, index) => {
            let payload: string = n.rawData && n.rawData ? n.rawData : "";
            try {
              if (!isHex(payload)) throw new Error("not hex");
              payload = textdecoder.decode(fromHex(payload, "bytes"));
            } catch {
              payload = "(hex) " + payload;
            }
            return (
              <tr key={`${index}`}>
                <td>{n.updatedAt.toLocaleString()}</td>
                <td>{n.inputIndex}</td>
                <td>{n.index}</td>
                <td>
                  <select onChange={(e) => selectDecoder(e, n)}>
                    <option value={""}>select decoder</option>
                    {Object.keys(decoders).map((func, index) => (
                      <option key={index} value={func}>
                        {func}
                      </option>
                    ))}
                  </select>
                </td>
                <td title={payload}>
                  {payload.length > 80 ? `${payload.slice(0, 80)}...` : payload}
                </td>
              </tr>
            );
          })}
        </tbody>
      </table>
    </div>
  );
};
